## Embedded Type

1. 임베디드 타입

-   새로운 값 타입을 직접 정의한 타입

2. 임베디드 타입 사용하는 방법

-   @Embeddable: 값 타입을 정의한 곳에 표시
-   @Embedded: 값 타입을 사용하는 곳에 표시
-   임베디드 타입은 기본 생성자가 필수
-   엔티티와 임베디드 타입 관계는 컴포지션
-   하이버네이트는 임베디드 타입을 컴포넌트라 칭함

3.  임베디드 타입과 테이블 매핑

-   임베디드 타입을 사용하기 전과 후의 매핑되는 테이블을 같음
-   임베디드 타입 덕분에 테이블을 아주 세밀하게 매핑하는 것이 가능

4. 임베디드 타입과 연관관계

-   임베디드 타입은 값 타입을 포함하거나 엔티티를 참조

5. @AttributeOverride

-   임베디드 타입에 정의한 매핑정보를 재정의

6. 임베디드 타입과 null

-   임베디드 타입이 null이면, 매핑한 컬럼 값은 모두 Null

7. 참고

-   https://velog.io/@conatuseus/JPA-%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C-%ED%83%80%EC%9E%85embedded-type-8ak3ygq8wo

## 식별자

1. 식별자 정의

-   중복 데이터가 없는 속성을 의미
-   하나의 엔티티는 하나 이상의 식별자를 반드시 보유해야 함

2. 식별자의 유형

-   후보식별자: 하나의 엔티티 내에서 식별자로 사용할 수 있는 키
-   주식별자: 엔티티의 대표성을 나타내는 유일한 식별자
-   보조식별자: 주식별자를 제외한 나머지
-   내부식별자: 자신의 엔티티 내에서 스스로 생성되어 존재하는 식별자
-   외부식별자(외래키): 다른 엔티티로부터 관계에 의해 주식별자 속성을 상속받아 자신의 속성에 포함되는 식별자
-   단일 식별자: 주식별자의 구성이 한가지인 경우
-   복합 식별자: 주식별자의 구성이 두개 이상인 경우 (우선순위가 중요)

3. 참고

-   https://valuefactory.tistory.com/221ㄴ

## 데이터 모델링

-   정보시스템 구축의 대상이 업무 내용을 분석하여 이해하고 약속된 표기업에 의해 표현하는것

1. 업무 파악

-   UI를 의뢰인과 함께 확인하며 요구사항 수집 및 분석

2. 개념적 데이터 모델링

-   하고자 하는 일의 데이터 간의 관계를 구상
-   각 개체들과 그들간의 관계를 발견하고 표현하기 위해 ERD 다이어그램 생성

3. 논리적 데이터 모델링

-   개념적 데이터 모델링을 구체화한 업무 중심의 데이터 모델

4. 물리적 데이터 모델링

-   최종적으로 데이터를 관리할 데이터베이스 선택
-   선택된 데이터 베이스에 실제 테이블을 만듬

5. 참고

-   https://inpa.tistory.com/entry/DB-%F0%9F%93%9A-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EB%A7%81-1N-%EA%B4%80%EA%B3%84-%F0%9F%93%88-ERD-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8

## ERD (Entity Relationship Diagram)

1. Entity: 데이터베이스의 테이블
2. Attribute: 테이블의 각 필드
3. Domain: 어트리뷰트가 가질 수 있는 범위

## ERD 엔티티 관계 표기법

1. 식별자 관계

-   실선으로 표현
-   부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본 키 + 외래 키로 사용하는 관계

2. 비식별자 관계

-   점선으로 표현
-   부모 테이블의 기본 키를 받아서 자식 테이블의 외래 키로만 사용하는 관계
-   필수적 비식별 관계: 외래 키에 NULL을 허용하지 않음
-   선택적 비식별 관계: 외래 키에 NULL 허용

## ERD 관계의 참여도

-   '|' 표시가 있는 곳은 반드시 있어야 하는 개체
-   'O' 표시가 있다면 없어도 되는 개체

## 상속 관계 매핑

1. 조인 전략

-   엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용하는 전략
-   객체는 타입으로 구분할 수 있지만, 테이블은 타입의 개념이 없기 때문에 타입을 구분하는 컬럼을 추가해야 함 (@DiscriminatorColumn)
-   @DiscriminatorValue: 구분 컬럼에 입력할 값을 지정
-   조회 쿼리가 복잡하지만, 저장공간이 효율적이며, 테이블 정규화가 가능해짐

2. 단일 테이블 전략

-   테이블 하나만 사용
-   조인이 필요 없으므로 일반적으로 조회 성능이 빠르지만 테이블이 너무 커질 수 있음
-   자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야함
-   구분 컬럼을 꼭 사용해야 함

3. 구현 클래스마다 테이블 전략

-   자식 엔티티 마다 테이블 생성
-   조회할 때 성능이 느림
-   거의 사용되지 않음

4. 주요 어노테이션

1) @Inheritance
   부모클래스에서 사용되며, 상속관계 매핑을 어떻게 구현할지 선택해줌  
   @Inheritance(strategy=InheritanceType.XXX  
   기본값은 단일 테이블 전략

2) @DiscriminatorColumn  
   슈퍼타입 테이블에 있는 정보가 어느 서브타입의 정보인지를 알려주는 컬럼을 만들어주는 어노테이션  
   기본값은 DYPE이며, 이 컬럼에 서브테이블의 명칭이 들어감  
   조인전략은 @DiscriminatorColumn을 선언하지 않으면 생성되지 않음  
   단일테이블 전략은 @DiscriminatorColumn을 선언하지 않아도 자동생성됨(테이블이 한개라서 DYPE없이는 테이블을 판단할 수 없음)

3) @MappedSuperclass  
   공통 매핑 정보가 필요할 때, 부모 클래스에 선언하고 속성만 상속받아서 사용하고 싶을 때 사용  
   직접 생성해서 사용할 일이 없으므로 추상 클래스를 이용

4. 참고

-   https://jojelly.tistory.com/144
-   https://ict-nroo.tistory.com/128
-   https://ict-nroo.tistory.com/129

## 연관관계 매핑

1. 단방향, 양방향

-   테이블은 외래 키 하나로 양 쪽 테이블 조인이 가능
-   객체는 참조용 필드가 있는 객체만 다른 객체로 참조하는 것이 가능
-   단방향: 두 객체 사이에 하나의 객체만 참조용 필드를 갖는 경우
-   양방향: 두 객체 모두가 각각 참조용 필드를 갖는 경우

2. 연관 관계의 주인

-   두 객체가 양방향 관계일때, 연관 관계의 주인을 지정해야 함
-   연관 관계의 주인을 지정하는건 두 객체 중 제어의 권한을 갖는 실질적인 관계가 어떤것인이 알려주는 역할
-   연관 관계의 주인이 아니면 조회만 가능
-   외래키가 있는 곳을 연관 관계의 주인으로 결정

3. 연관 관계의 주인만 제어하면 되나?

-   데이터베이스만 고려하면 주인만 제어해도됨
-   객체를 생각해보면 둘다 변경해주는것이 좋음

4. 참고

-   https://jeong-pro.tistory.com/231
-   https://ttl-blog.tistory.com/126
-   https://velog.io/@dhk22/JPA-%EC%96%91%EB%B0%A9%ED%96%A5-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84

## 다대일 관계

1. 다대일

-   테이블관점에서, 일대다에서 다 쪽에 외래키가 있어야 함

2. 다대일 단방향 매핑

-   @ManyToOne을 사용하여 다대일 관계 매핑
-   @JoinColumn을 사용하여 외래키 매핑

3. 다대일 양방향 매핑

-   이미 단방향 매핑이 된 상태에서, 반대편에서 단방향 매핑을 추가로 진행하는 상황
-   반대편에서 단방향 매핑을 하는것은 데이터베이스에 아무런 영향을 주지 않음
-   반대편에서 @OneToMany(mappedBy = 필드명) 추가

4. 참고

-   참고: https://ict-nroo.tistory.com/124

## 일대일 관계

1. 일대일

-   주 테이블이나 대상 테이블 중 외래 키를 넣을 테이블을 선택 가능
-   외래 키에 유니크 제약조건을 추가해야 함

2. 주 테이블에 외래 키 단방향

-   다대일 단방향 관계 매핑과 JPA 어노테이션만 달라지고, 거의 유사

3. 주 테이블에 외래 키 양방향

-   외래키가 있는 곳이 연관관계의 주인
-   주인 테이블에 @OneToOne, @JoinColumn 사용
-   대상 테이블에 @OneToOne(mappedBy = 필드명) 사용 (읽기만 가능)

4. 대상 테이블에 외래 키 단방향

-   JPA에서 지원 x

5. 대상 테이블에 외래 키 양방향

-   주인 테이블에 @OneToOne(mappedBy = 필드명)사용
-   대상 테이블에 @OneToOne, @JoinColumn 사용 (읽기만 가능)

## 조인 테이블

1. 데이터베이스 테이블의 연관관계를 성계하는 방법

-   조인 컬럼 사용: 외래 키 컬럼을 사용해서 관리
-   조인 테이블 사용: 조인 테이블을 추가하고 두 테이블의 외래 키를 가지고 연관 관계를 관리

2. @JoinTable 속성

-   name: 매핑할 조인 테이블 이름
-   joinColumns: 현재 엔티티를 참조하는 외래 키
-   inverseJoinColumns: 반대방향 엔티티를 참조하는 외래 키

3. 참고: 자바 ORM 표준 JPA 프로그래밍

## CASCADE

-   특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 전이되는 것을 의미
-   JPA에서는 엔티티간의 의존성을 설정하기 위해 CascadeType을 제공
-   참고: https://zzang9ha.tistory.com/350

## 즉시로딩, 지연로딩

-   Fetch Type: JPA가 참조하는 객체들의 데이터를 가져오는 시점을 의미
-   EAGER: 하나의 객체를 데이터베이스로부터 읽어올 때 참조 객체들의 데이터까지 전부 읽음
-   LAZY: 참조 객체들의 데이터들은 무시하고 해당 엔티티의 데이터만 가져옴
-   참고: https://velog.io/@bread_dd/JPA%EB%8A%94-%EC%99%9C-%EC%A7%80%EC%97%B0-%EB%A1%9C%EB%94%A9%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C
